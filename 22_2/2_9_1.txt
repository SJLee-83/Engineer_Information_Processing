현재 IP 주소가 192.168.1.132이고, 서브넷 마스크가 255.255.255.192일 때, 네트워크 주소는 192.168.1.(1)이고, 
해당 네트워크에서 네트워크 주소와 브로드캐스트 주소를 제외한 사용 기능 호스트의 수는 (2)개이다.

정답은 (1) **128**, (2) **62**입니다.

-----

## \#\# (1) 네트워크 주소 풀이

네트워크 주소는 **IP 주소**와 **서브넷 마스크**를 2진수로 변환한 뒤, 비트 단위로 **AND 연산**을 수행하여 구합니다.

1.  **서브넷 마스크 확인**: `255.255.255.192`

      * 첫 번째, 두 번째, 세 번째 옥텟(octet)이 `255`이므로, IP 주소의 첫 세 옥텟(`192.168.1`)은 그대로 네트워크 주소가 됩니다.
      * 핵심은 네 번째 옥텟입니다.

2.  **네 번째 옥텟 2진수 변환**:

      * IP 주소 `132`: 128 + 4 = **`10000100`**
      * 서브넷 마스크 `192`: 128 + 64 = **`11000000`**

3.  **비트 AND 연산**:
    두 2진수를 비트별로 `AND` 연산합니다. (두 비트가 모두 1일 때만 1)

    ```
      10000100  (132)
    & 11000000  (192)
    ------------------
      10000000
    ```

4.  **10진수 변환**:

      * `10000000` (2진수) = **128** (10진수)

따라서 네트워크 주소는 `192.168.1.128`이며, (1)에 들어갈 답은 **128**입니다.

-----

## \#\# (2) 사용 가능 호스트 수 풀이

1.  **호스트 비트 계산**:

      * 서브넷 마스크 `255.255.255.192`를 2진수로 변환하면, 네트워크를 나타내는 '1'의 개수 뒤에 호스트를 나타내는 **'0'의 개수**가 나옵니다.
      * `11111111.11111111.11111111.11000000`
      * 호스트를 식별하기 위한 '0' 비트는 총 **6개**입니다.

2.  **총 IP 개수 계산**:

      * 호스트 비트가 $n$개일 때, 해당 네트워크의 총 IP 개수는 $2^n$입니다.
      * $2^6$ = **64개** (0 \~ 63, 이 경우 128 \~ 191)

3.  **사용 가능 호스트 수 계산**:

      * 총 IP 개수(64개) 중 2개는 특별한 용도로 예약되어 있어 사용자가 쓸 수 없습니다.
          * **네트워크 주소**: `192.168.1.128` (모든 호스트 비트가 0)
          * **브로드캐스트 주소**: `192.168.1.191` (모든 호스트 비트가 1)
      * 따라서 사용자가 실제 장치에 할당할 수 있는 IP의 수는 (총 IP 개수 - 2)입니다.
      * $64 - 2$ = **62개**

(2)에 들어갈 답은 **62**입니다.

====================================================================

Q, 서브넷 마스크를 이진수로 변환했을 때, 4번째 옥텟이 '10100100' 이런식으로 나올 수도 있나? 나온다면 절럴 때는 0의 갯수는 2개인가?

아니요, **절대로 그렇게 나올 수 없습니다.**

서브넷 마스크의 2진수 값은 **반드시 `1`이 연속으로 나온 뒤에 `0`이 연속으로 나와야 한다**는 철저한 규칙을 따릅니다.

`1`과 `0`이 `10100100`처럼 중간에 섞여 있을 수 없습니다.

---
## ## 서브넷 마스크의 규칙

서브넷 마스크는 IP 주소의 32비트 공간에서 "어디까지가 네트워크 영역이고, 어디부터가 호스트 영역인지"를 구분하는 **단 하나의 경계선** 역할만 합니다.

* `1`이 연속되는 부분: 네트워크 영역
* `0`이 연속되는 부분: 호스트 영역

따라서 `255.255.255.0`은 2진수로 다음과 같습니다.
`11111111.11111111.11111111.00000000`
(24개의 `1`이 연속 + 8개의 `0`이 연속)

---
## ## 경계선이 옥텟 중간에 걸칠 때

만약 경계선이 4번째 옥텟(8비트) 중간에 걸친다면, 그 옥텟 안에서도 `1`이 먼저 나오고 `0`이 나와야 합니다.

예를 들어, 4번째 옥텟이 `11000000` (`192`)인 경우는 유효합니다. 하지만 `10100000` 같은 값은 `1` 사이에 `0`이 끼어 있으므로 **절대 유효한 서브넷 마스크 값이 될 수 없습니다.**

유효한 4번째 옥텟의 값은 다음과 같이 정해져 있습니다.
* `00000000` (0)
* `10000000` (128)
* `11000000` (192)
* `11100000` (224)
* `11110000` (240)
* `11111000` (248)
* `11111100` (252)
* `11111110` (254)
* `11111111` (255)

---
## ## 0의 개수를 세는 방법

질문하신 `10100100`은 유효하지 않은 마스크이지만, 만약 유효한 마스크인 **`11000000`** (`192`)에서 0의 개수를 센다면, 말씀하신 2개가 아니라 그 옥텟에 있는 **모든 0의 개수**인 **6개**가 됩니다.

호스트의 개수를 결정하는 것은 마스크 전체(32비트)에서 **연속된 0의 총 개수**입니다.