class Parent {
    int x = 1000;
    Parent() {
        this(3000);
    }
    Parent(int x) {
        this.x = x;
    }
}

class Child extends Parent {
    int x = 4000;
    Child() {
        this(5000); // -> Child(int x) x=5000 #1
    }
    Child(int x) { // super() 자동 생성 #2
        this.x = x;
    }
    int getX() {
        return this.x;
    }
}

public class Test {
    public static void main(String[] args) {
        Child c = new Child();
        System.out.println(c.getX())
    }
}

// #1
// this()를 생성자 안에서 사용하는 것은 자바의 특별한 문법입니다.

// 이는 **"이 클래스 내의 다른 생성자를 호출하라"**는 명령어입니다. 📞

//     Child() 생성자가 호출되었습니다.

//     Child()는 자신의 첫 번째 줄에서 **this(5000)**을 만났습니다.

//     이것은 "지금 나(Child())를 호출한 것은 알겠는데, 일단 멈추고 같은 Child 클래스 안에 있는 생성자 중에서 int 값 하나를 받는 생성자를 먼저 실행해 줘. 그리고 값은 5000을 넘겨."라는 뜻입니다.

//     자바는 Child 클래스 내부에서 int 하나를 받는 생성자를 찾습니다.

//     Child(int x) { ... }가 이 조건과 정확히 일치합니다.

//     따라서 Child(int x)가 x = 5000 값을 가지고 먼저 실행되는 것입니다.

// ## 비유: 업무 위임 🧑‍💼
//     Child() (기본 생성자): "기본 업무 담당자"입니다.

//     Child(int x) (다른 생성자): "구체적인 업무 담당자"입니다.

// main에서 "기본 업무"를 시켰더니(new Child()), "기본 업무 담당자"가 "아, 이 일은 '구체적인 업무 담당자'에게 5000이라는 값을 줘서 처리하라고 넘겨야겠다"(this(5000))라고 일을 **위임(delegation)**한 것입니다.

// 이렇게 하는 주된 이유는 코드 중복을 피하기 위해서입니다. 객체를 초기화하는 실제 로직을 Child(int x) 한 곳에만 작성해두고, 기본 생성자는 그저 특정 값을 넘겨 재사용하는 것이죠.


// #2
// 그것은 자바의 상속에서 가장 중요하고, 때로는 헷갈리는 규칙입니다.

// **"자식 클래스 객체를 만들기 전에, 부모 클래스 객체가 반드시 먼저 완성되어야 한다"**는 자바의 철칙 때문입니다. 🏠

// 이 규칙을 지키기 위해, 자바는 모든 자식 클래스의 생성자에 다음과 같은 규칙을 강제합니다.

//     자식 생성자는 자신의 코드를 실행하기 전에, 맨 첫 줄에서 부모 생성자(super(...))를 호출하거나 아니면 자신의 다른 생성자(this(...))를 호출해야만 합니다.

// 이 규칙 때문에 두 가지 경우가 발생합니다.

// ## 1. 개발자가 super(...)를 직접 작성하는 경우 (명시적 호출)
// 말씀하신 대로, 부모의 생성자에 값을 넘겨야 할 때는 개발자가 super(...)를 직접 작성해야 합니다.

// class Child extends Parent {
//     Child(int x) {
//         // 부모의 Parent(int x) 생성자를 "명시적"으로 호출
//         super(x); 
//     }
// }

// 이 경우 컴파일러는 "OK, 개발자가 부모 생성자를 잘 호출했군." 하고 넘어갑니다.

// ## 2. 개발자가 아무것도 작성하지 않는 경우 (암묵적 호출)
// 이것이 바로 질문하신 상황입니다. Child(int x) 생성자에는 super(...)나 this(...)가 첫 줄에 명시되어 있지 않았습니다.

// class Child extends Parent {
//     Child(int x) {
//         // (첫 줄에 아무것도 없음)
//         this.x = x; 
//     }
// }

// 이때 컴파일러는 "어, 부모 생성자 호출이 없네? 그럼 규칙에 따라 내가 기본 생성자인 super();를 맨 첫 줄에 자동으로 삽입해야겠다."라고 판단합니다.
// 그래서 코드는 사실상 다음과 같이 번역됩니다.

// class Child extends Parent {
//     Child(int x) {
//         super(); // <-- 컴파일러가 자동으로 이 코드를 삽입!
//         this.x = x; 
//     }
// }

// 이 자동 삽입된 super();가 Parent() 기본 생성자를 호출하게 된 것입니다.

// ## Child() 생성자와의 비교
// 재미있는 점은, Child() 기본 생성자는 super();가 자동으로 삽입되지 않았다는 것입니다.

// Child() {
//     this(5000); // <-- 첫 줄에 this(...)가 이미 있음
// }

// 컴파일러는 Child()의 첫 줄을 보고 "OK, this(...) 호출이 있네. 부모를 호출하는 책임은 this(5000)이 알아서 하겠지."라고 판단하여 super();를 삽입하지 않습니다.

// 결론적으로, 개발자가 자식 생성자 첫 줄에 super(...)나 this(...)를 명시하지 않을 때만, 컴파일러가 부모의 기본 생성자를 호출하는 super();를 자동으로 넣어줍니다.


// # 코드 실행 과정
// 1. main 메서드 시작: Child c = new Child(); Child 클래스의 기본 생성자(매개변수가 없는)를 호출하여 c 객체를 생성합니다.

// 2. Child() 생성자 호출 Child 생성자의 첫 줄인 this(5000);이 실행됩니다. 이는 Child 클래스 자신의 다른 생성자인 Child(int x)를 x=5000 값으로 호출합니다.

// 3. Child(int x) 생성자 호출 (x = 5000) 이 생성자에는 super()가 명시적으로 없으므로, 컴파일러는 자동으로 맨 첫 줄에 super();를 삽입합니다. 이는 부모 클래스인 Parent의 기본 생성자를 호출합니다.

// 4. Parent() 생성자 호출 Parent 생성자의 첫 줄인 this(3000);이 실행됩니다. 이는 Parent 클래스 자신의 다른 생성자인 Parent(int x)를 x=3000 값으로 호출합니다.

// 5. Parent(int x) 생성자 호출 (x = 3000) this.x = x;가 실행됩니다. 여기서 this.x는 **Parent 클래스의 x**를 의미합니다. Parent의 x 값이 1000에서 3000으로 변경됩니다.

// 6. 생성자 복귀 (1) Parent(int x)가 완료되고, Parent()로 돌아옵니다. Parent()도 완료되고, Child(int x)로 돌아옵니다.

// 7. Child(int x) 생성자 재개 (x = 5000) super() 호출이 끝났으므로, 다음 코드인 this.x = x;가 실행됩니다. 여기서 this.x는 **Child 클래스의 x**를 의미합니다. 
// (이것이 필드 숨김입니다. Child의 x가 Parent의 x를 가립니다.) Child의 x 값이 4000에서 5000으로 변경됩니다.

// 8. 생성자 복귀 (2) Child(int x)가 완료되고, Child()로 돌아옵니다. Child()도 완료되어 객체 c의 생성이 모두 끝납니다.

//     ※ 이 시점에 객체 c의 상태:

//         Parent 부분의 x: 3000

//         Child 부분의 x: 5000

// 9. getX() 메서드 호출: System.out.println(c.getX()); c 객체의 getX() 메서드를 호출합니다. getX() 메서드는 Child 클래스에 정의되어 있습니다.

// 10. getX() 실행: return this.x; getX() 메서드는 this.x를 반환합니다. this는 Child 객체를 가리키므로, this.x는 Child 클래스의 x 값인 5000을 반환합니다.

// 11. 출력: 5000이 화면에 출력됩니다.