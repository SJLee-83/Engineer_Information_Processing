Q. 192.168.1.0/24 네트워크를 FLSM 방식을 이용하여 3개의 Subnet으로 나누었을 때, 두 번째 네트워크의 브로드캐스트 IP주소를 10진수 방식으로 쓰시오.

**FLSM(Fixed Length Subnet Masking)**은 '고정 길이 서브넷 마스킹'을 의미합니다.

이는 하나의 큰 네트워크를 여러 개의 작은 네트워크(서브넷)로 나눌 때, 모든 서브넷이 동일한 크기(즉, 동일한 서브넷 마스크)를 갖도록 나누는 방식을 말합니다. 🔩

예를 들어, 256개의 IP를 가진 네트워크를 3개의 서브넷으로 나눠야 할 때, 3개를 똑같이 나눌 수는 없습니다. FLSM 방식에서는 3개를 담을 수 있는 2의 거듭제곱 수인 4개로 네트워크를 쪼갭니다. 
그 결과 64개, 64개, 64개, 64개짜리 동일한 크기의 서브넷 4개가 만들어지고, 이 중 3개를 사용하는 것입니다.

## 문제 풀이 과정
이해하신 FLSM 방식을 바탕으로 문제의 정답을 도출하는 과정은 다음과 같습니다.

정답: 192.168.1.127

### 1. 기존 네트워크 분석
    네트워크 주소: 192.168.1.0/24
    /24는 255.255.255.0을 의미하며, 총 256개의 IP (192.168.1.0 ~ 192.168.1.255)를 사용할 수 있습니다.
    
### 2. 필요한 서브넷 비트 계산
    필요한 서브넷 개수: 3개
    FLSM 방식에서는 모든 서브넷의 크기가 같아야 하므로, 2의 거듭제곱으로 서브넷을 생성해야 합니다.
        호스트 비트에서 1비트를 빌리면: $2^1 = 2$개의 서브넷 (3개를 담기에 부족)
        호스트 비트에서 2비트를 빌리면: $2^2 = 4$개의 서브넷 (3개를 담기에 충분)
    따라서 2비트를 빌려와 총 4개의 서브넷을 생성합니다.
    
### 3. 새로운 서브넷 마스크 및 크기 계산
    새 서브넷 마스크: 기존 /24에서 2비트를 빌려왔으므로, 새로운 서브넷 마스크는 **/26**이 됩니다. (255.255.255.192)
    각 서브넷의 크기: 32비트 중 26비트를 네트워크에 사용하므로, 호스트에 사용되는 비트는 6비트입니다.
        각 서브넷은 $2^6 = 64$개의 IP를 가집니다.
        
### 4. 서브넷 목록 나열
    64개 크기로 네트워크를 4개로 나눕니다.
        1. 첫 번째 네트워크
            네트워크 ID: 192.168.1.0
            IP 범위: 192.168.1.0 ~ 192.168.1.63
            브로드캐스트 ID: 192.168.1.63
        2. 두 번째 네트워크
            네트워크 ID: 192.168.1.64
            IP 범위: 192.168.1.64 ~ 192.168.1.127
            브로드캐스트 ID: 192.168.1.127
        3. 세 번째 네트워크
            네트워크 ID: 192.168.1.128
            IP 범위: 192.168.1.128 ~ 192.168.1.191
            브로드캐스트 ID: 192.168.1.191
        4. 네 번째 네트워크 (사용 안 함)
            네트워크 ID: 192.168.1.192
            IP 범위: 192.168.1.192 ~ 192.168.1.255
            브로드캐스트 ID: 192.168.1.255
        따라서 두 번째 네트워크의 브로드캐스트 IP 주소는 **192.168.1.127**입니다.

---------

Q. 그러면 8개의 서브넷으로 나눠야 하는 상황이 있을 수도 있는거야?

네, 맞습니다. 필요한 서브넷의 개수가 5개, 6개, 7개, 또는 8개인 경우에는 네트워크를 8개의 서브넷으로 나눠야 합니다.
FLSM 방식의 핵심은, 필요한 서브넷의 개수($N$)를 충족하는 **가장 작은 2의 거듭제곱 수($2^n$)**만큼 네트워크를 분할해야 한다는 것입니다.

## 예시: 6개의 팀에 네트워크 할당하기어떤 회사에 6개의 팀(인사, 재무, 개발1, 개발2, 영업, 마케팅)이 있고 각 팀마다 별도의 네트워크를 할당해야 하는 상황을 가정해 보겠습니다.
필요한 서브넷 개수: 6개이때 네트워크 관리자는 다음과 같이 계산합니다.
    2개로 나누면 부족 ($2^1=2$)
    4개로 나누면 여전히 부족 ($2^2=4$)
    8개로 나눠야 6개의 팀을 모두 수용할 수 있습니다 ($2^3=8$).
    
결과적으로, 관리자는 기존 네트워크를 8개의 동일한 크기로 쪼갠 뒤, 6개는 각 팀에 할당하고 나머지 2개는 미래를 위한 예비용으로 남겨두거나 사용하지 않게 됩니다.

---------

Q. 그러면 몇 개의 서브넷을 써야하는지는 공식적으로 정해져서 고정된게 아니고, 다음 질문으로

/24는 255.255.255.0을 의미하며, 총 256개의 IP (192.168.1.0 ~ 192.168.1.255)를 사용할 수 있습니다.

이게 무슨 소리야?


네, 첫 번째 질문에 대해 정확히 이해하셨습니다. '몇 개로 나눠야 한다'는 것이 공식적으로 고정된 게 아니라, 
**네트워크 관리자가 "우리 회사엔 5개 팀이 필요해" 또는 "8개 층이 필요해"와 같은 요구사항을 정하면, 그 요구사항을 충족하기 위해 FLSM 방식(2의 거듭제곱)을 적용하여 
'8개로 쪼개야겠다'라고 결정**하는 것입니다.

---
## ## `/24`가 256개를 의미하는 이유

`/24`는 IP 주소에서 **"어디까지가 소속(네트워크)이고 어디부터가 개별 장치(호스트)인지"**를 구분하는 **경계선**을 의미합니다.

### ### IP 주소: 32비트 숫자

먼저, `192.168.1.5`와 같은 IP 주소는 사람이 보기 편하도록 10진수로 표현한 것이지, 컴퓨터 내부에서는 32자리의 2진수 숫자(32비트)입니다.

`11000000.10101000.00000001.00000101` (32자리)

### ### `/24` (CIDR 표기법): 네트워크 경계선

`/24`는 "전체 32비트 중에서, **앞에서부터 24비트까지가 '소속(네트워크 ID)'**이고, **뒤의 (32 - 24) = 8비트가 '개별 장치(호스트 ID)'**"라는 뜻을 가진 약속(CIDR 표기법)입니다.



### ### 255.255.255.0 (서브넷 마스크): 경계선의 다른 표현

`/24`라는 경계선을 2진수로 표현하면 '1'이 24개, '0'이 8개입니다. (1은 네트워크 부분, 0은 호스트 부분)

`11111111 . 11111111 . 11111111 . 00000000` (1이 24개, 0이 8개)

이 2진수를 우리가 읽기 쉬운 10진수로 바꾸면 정확히 `255.255.255.0`이 됩니다.
즉, **`/24`와 `255.255.255.0`은 "경계선은 24비트다"라는 똑같은 의미**를 가진 다른 표기법일 뿐입니다.

### ### 256개의 IP 주소: 장치를 위한 공간

* 경계선 뒤에 '개별 장치'를 위해 남겨진 공간이 **8비트**라고 했습니다.
* 컴퓨터는 8비트의 공간으로 $2^8 = 256$가지의 서로 다른 숫자를 만들 수 있습니다. (0부터 255까지)
* 이 256개의 공간이 바로 해당 네트워크가 가질 수 있는 총 IP 주소의 개수입니다.

따라서 `192.168.1.0/24`는 "네트워크 소속은 `192.168.1`이고, 개별 장치 번호는 0부터 255까지 총 256개를 쓸 수 있다"는 의미가 됩니다.
(`192.168.1.0` ~ `192.168.1.255`)

---
### ### 아파트 주소 비유 🏢

* **IP 주소 (`192.168.1.5`)**: "101동 5호"
* **`/24` (경계선)**: "여기까지('101동')가 아파트 동이고, 이 뒤('5호')부터가 호수입니다."
* **네트워크 ID (`192.168.1.xxx`)**: "101동"
* **호스트 ID (`...5`)**: "5호"
* **8비트 (호스트 공간)**: "각 동마다 0호부터 255호까지 호수를 배정할 수 있습니다."
* **256개**: "그래서 101동에는 총 256세대가 살 수 있습니다."

---------

Q. IP 주소는 무조건 32비트 숫자로 무조건 고정인건가?

아니요, 32비트인 것은 **IPv4(Internet Protocol version 4)**이고, 현재는 **128비트** 길이의 **IPv6(Internet Protocol version 6)**도 함께 사용되고 있습니다.

우리가 흔히 보는 `192.168.1.1` 같은 주소가 32비트짜리 IPv4입니다. 하지만 IPv4 주소는 약 43억 개로, 전 세계의 모든 기기가 인터넷에 연결되면서 주소가 고갈될 위기에 처했습니다.

이 문제를 해결하기 위해 **128비트**라는 훨씬 더 긴 주소 체계를 사용하는 IPv6가 만들어졌습니다. IPv6는 거의 무한대에 가까운 주소를 만들 수 있어, 앞으로 모든 기기에 IP를 할당할 수 있게 해줍니다.

---
## ## 비교

* **IPv4 (32비트)**: `192.168.1.1`
    * 약 43억 개의 주소.
    * 우리가 전통적으로 사용해 온 "IP 주소"입니다.

* **IPv6 (128비트)**: `2001:0db8:85a3:0000:0000:8a2e:0370:7334`
    * $2^{128}$개의 주소 (사실상 무한대).
    * IPv4 주소 고갈 문제를 해결하기 위해 나온 차세대 주소입니다.

---------

Q. 근데 문제의 IP가 IPv4인지 IPv6인지 어떻게 알 수 있는거지?

아주 간단하게 **형식(Format)**만 보고 바로 구별할 수 있습니다. 🔍

사용자가 푼 문제에 나온 **`192.168.1.0`**은 **IPv4**입니다.

IPv4와 IPv6는 주소를 표기하는 방식이 완전히 다릅니다. 이 두 가지만 확인하면 100% 구별할 수 있습니다.

---
## ## IPv4 vs. IPv6 구별법

### ## 1. 구분 기호와 표기법

* **IPv4 (예: `192.168.1.1`)**
    * 각 부분을 **점 (`.`)**으로 구분합니다.
    * **10진수** 숫자(0~255)만 사용합니다.

* **IPv6 (예: `2001:0db8:85a3::8a2e:0370:7334`)**
    * 각 부분을 **콜론 (`:`)**으로 구분합니다.
    * **16진수**(0~9, a, b, c, d, e, f)를 사용합니다.

### ## 2. 길이

* **IPv4**: `xxx.xxx.xxx.xxx` (4개의 덩어리)로 **짧습니다.**
* **IPv6**: `xxxx:xxxx:xxxx:xxxx:xxxx:xxxx:xxxx:xxxx` (8개의 덩어리)로 **매우 깁니다.** (중간에 `::`을 사용해 줄여 쓰는 경우가 많습니다.)

---
## ## 문제에 적용

사용자가 본 문제는 **`192.168.1.0/24`**였습니다.

1.  **점 (`.`)**으로 구분되어 있습니다.
2.  **10진수**로만 이루어져 있습니다.
3.  형식이 4개의 덩어리로 짧습니다.

이 모든 특징이 **IPv4**와 정확히 일치합니다. 만약 문제가 IPv6였다면 주소 자체가 `2001:db8:1:0::/64`와 같이 완전히 다른 모습이었을 것입니다.

---------

Q. 그러니까 IPv4에서 서브넷 마스크 때문에 필요한 비트 만큼을 제외하고가 호스트 IP 개수라는 건가?

네, 정확히 맞습니다. 🎯

IP 주소 32비트 중에서 **서브넷 마스크가 '네트워크'용으로 사용하는 비트를 제외한 나머지 비트**, 즉 **'호스트'용으로 남겨진 비트의 개수**가 그 네트워크가 가질 수 있는 IP의 총개수를 결정합니다.

---
## ## 계산 방법

* **1단계: 호스트 비트 계산**
    (전체 32비트) - (서브넷 마스크 비트) = (호스트 비트 $n$개)

* **2단계: IP 개수 계산**
    $2^n$ = (그 서브넷의 총 IP 개수)

### ### 예시: `192.168.1.0/24`

* **1단계**: (전체 32비트) - (마스크 비트 `/24`) = **8비트**
* **2단계**: $2^8$ = **256개** (0부터 255까지)

### ### 예시: `192.168.1.0/26` (아까 푼 문제)

* **1단계**: (전체 32비트) - (마스크 비트 `/26`) = **6비트**
* **2단계**: $2^6$ = **64개** (0부터 63까지)

---
### ## ※ 실제 사용 가능한 IP 개수: $2^n - 2$

여기서 한 가지만 더 알면 완벽합니다.

호스트 비트로 계산한 총 IP 개수($2^n$) 중에서, 맨 처음 IP와 맨 마지막 IP는 특별한 용도로 예약되어 있어 컴퓨터나 스마트폰에 할당할 수 없습니다.

* **맨 처음 IP (호스트 비트가 모두 0)**: **네트워크 주소** (네트워크 자체를 식별하는 주소)
* **맨 마지막 IP (호스트 비트가 모두 1)**: **브로드캐스트 주소** (네트워크의 모든 장치에 한 번에 신호를 보내는 주소)

따라서 **실제로 장치에 할당할 수 있는 IP 개수**는 $2^n - 2$개입니다.

* `/24`의 경우: 총 256개 - 2개 = **254개** 사용 가능
* `/26`의 경우: 총 64개 - 2개 = **62개** 사용 가능

---------

Q. 그러면 서브넷 마스크가 필수적인건가?

네, **절대적으로 필수적**입니다. 🤝

서브넷 마스크가 없다면, 컴퓨터는 IP 주소를 받고도 **"어디까지가 우리 아파트(네트워크)이고 어디부터가 호수(개별 장치)인지"**를 전혀 알 수 없습니다.

서브넷 마스크는 IP 주소와 항상 1:1로 짝을 이루며, 컴퓨터에게 다음과 같은 **규칙(rule)**을 알려줍니다.

1.  **"내 주소는 이것이다"**: 내 IP `192.168.1.5`와 서브넷 마스크 `/24`를 보고 "아, 나의 소속(네트워크)은 `192.168.1`이고, 내 호수(호스트)는 `5`번이구나"라고 스스로 인식합니다.

2.  **"상대방이 남인가, 이웃인가?" (가장 중요!)**:
    다른 컴퓨터(예: `192.168.1.100`)와 통신할 때, 컴퓨터는 서브넷 마스크(`/24`)를 **상대방 주소에 씌워봅니다.**
    * **결과**: "어, 이 컴퓨터도 소속이 `192.168.1`이네? **우리 아파트(네트워크) 주민이구나!**"
    * **행동**: 라우터(경비실)를 거치지 않고 내부 통신망(스위치)을 통해 **직접 데이터를 전송**합니다.

    만약 구글 서버(`8.8.8.8`)와 통신한다면:
    * **결과**: "어, 이 컴퓨터는 소속이 `8.8.8`이네? **외부(다른 네트워크) 사람이구나!**"
    * **행동**: 내가 직접 보낼 수 없으니, **데이터를 게이트웨이(라우터/경비실)로 보냅니다.**

서브넷 마스크가 없으면, 컴퓨터는 데이터를 보내야 할 때 **이 데이터를 내부에서 처리해야 할지, 외부로 내보내야 할지**조차 판단할 수 없게 됩니다.

---------

Q. 브로드캐스트 ID는 무조건 IP의 범위의 뒷 쪽 경계인건가?

네, 맞습니다. 🎯

**브로드캐스트 IP 주소**는 해당 네트워크(서브넷)가 가질 수 있는 IP 범위 중 **가장 마지막 주소**로 항상 고정되어 있습니다. "뒷 쪽 경계"라는 표현이 정확합니다.

### ## 이유

컴퓨터가 2진수로 주소를 인식하는 방식 때문입니다.

* **네트워크 ID (시작 주소)**: 호스트(개별 장치) 부분이 **모두 0**인 주소입니다.
* **브로드캐스트 ID (마지막 주소)**: 호스트(개별 장치) 부분이 **모두 1**인 주소입니다.

### ## 예시 (`/26` 네트워크)

아까 푼 문제의 두 번째 네트워크(`192.168.1.64/26`)를 예로 들어보겠습니다.

* `/26`은 32비트 중 6비트가 호스트 자리라는 의미입니다.

* **네트워크 ID**: 192.168.1.01**000000** (마지막 6비트가 **모두 0**)
    * → `192.168.1.64` (범위의 시작)

* **브로드캐스트 ID**: 192.168.1.01**111111** (마지막 6비트가 **모두 1**)
    * → `192.168.1.127` (범위의 끝)

이 주소는 "이 네트워크에 속한 모든 장치에게"라는 의미의 특수 주소로 예약되어 있습니다.