public class Main{
    public static void main(String[] args) {
        B a = new D();
        D d = new D();
        System.out.print(a.getX() + a.x + b.getX() + b.x);
    }
}

class B {
    int x = 3;
    int getX() {
        return x * 2;
    }
}

class D extends B { // B:부모클래스, D:자식클래스, D는 B의 한 종류이다.
    int x = 7; // 필드 숨김
    int getX() { // 메서드 오버라이딩
        return x * 3;
    }
}

// ## 상속의 핵심 규칙: 메서드 오버라이딩 vs. 필드 숨김
// 질문하신 코드의 핵심은 상속 관계에서 메서드와 **필드(변수)**를 호출하는 방식이 다르다는 점입니다.

// ### 1. 메서드 오버라이딩 (Method Overriding) 🎤
// 메서드 오버라이딩은 부모에게 물려받은 기능(메서드)을 자식이 자신만의 방식대로 재정의하는 것입니다.

// 규칙: 메서드를 호출할 때는 변수의 타입이 아니라, 실제로 생성된 객체의 타입을 따릅니다. (동적 바인딩)

// 비유: 부모(B)가 "노래하기(getX)"라는 재능을 물려줬지만, 자식(D)은 자신만의 스타일로 "오페라처럼 노래하기(getX)"로 바꿔 부르는 것과 같습니다. 
// 누구에게 노래를 시키든, 실제로 노래하는 사람의 스타일이 드러납니다.

// ### 2. 필드 숨김 (Field Hiding/Shadowing) 👤
// 필드 숨김은 자식 클래스가 부모와 똑같은 이름의 필드(변수)를 선언하는 경우입니다. 이 경우 자식의 필드가 부모의 필드를 가려서(숨겨서) 안 보이게 할 뿐, 부모의 필드가 사라지는 것은 아닙니다.

// 규칙: 필드에 접근할 때는 실제로 생성된 객체가 무엇이든 상관없이, **변수를 선언할 때 사용한 타입(참조 타입)**을 따릅니다. (정적 바인딩)

// 비유: 부모(B)도 x라는 이름의 통장을, 자식(D)도 x라는 이름의 통장을 가지고 있습니다. 
// 이때 B 타입의 카드로 돈을 찾으면(a.x) 부모 통장에서 돈이 나가고, D 타입의 카드로 돈을 찾으면(d.x) 자식 통장에서 돈이 나갑니다.