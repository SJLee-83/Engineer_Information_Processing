class Car implements Runnable {
    int a;
    public void run() {
        try{
            while(++a < 100) {
                System.out.println("miles traveled : " + a);
                Thread.sleep(100);
            }
        } catch(Exception E) {}
    }
}

public class Test {
    public static void main(String args[]) {
        Thread t1 = new Thread(new Car());
        t1.start();
    }
}

// 우선 인스턴스 변수 선언 규칙에 대해서 질문하자.

// 22_2 - 2_17_1.java 코드

// 이 코드에서는 class cond의 int a는 기본값이 할당되지 않은이유가 뭐지?

// ---------------------

// `int a`는 **기본값이 할당되었습니다.** 🥳

// 자바의 규칙에 따라 `new cond(3);` 코드로 `obj` 객체가 메모리에 생성되는 바로 그 순간, `int a`는 **기본값 `0`으로 자동 초기화**됩니다.

// 하지만 이 `0`이라는 값은 생성자가 실행되면서 **즉시 덮어쓰기**되기 때문에 우리가 볼 틈이 없는 것입니다.

// ---
// ### ## `obj.a`의 값 변경 역사

// `obj.a`라는 하나의 변수가 겪은 일을 시간순으로 보면 명확합니다.

// 1.  **`new cond(3)` (객체 생성 순간)**
//     * `obj` 객체가 메모리에 생성됩니다.
//     * `int a`는 인스턴스 변수 규칙에 따라 **기본값 `0`**을 할당받습니다.
//     * **(현재 `obj.a` = 0)**

// 2.  **`public cond(int a)` (생성자 실행)**
//     * 객체 생성 직후 생성자가 호출됩니다. (`a=3`이 전달됨)
//     * `this.a = a;` 코드가 `obj.a`의 값을 `3`으로 **덮어씁니다.**
//     * **(현재 `obj.a` = 3)**

// 3.  **`obj.a = 5;` (`main` 메서드 실행)**
//     * `main` 함수가 `obj.a`의 값을 `5`로 **또 덮어씁니다.**
//     * **(현재 `obj.a` = 5)**

// 4.  **`obj.func();` (메서드 실행)**
//     * `func` 메서드가 `a`의 값을 사용할 때는, 이 **최종 값인 `5`**를 사용하게 됩니다.

// `Car` 클래스와의 차이점은, `Car`는 생성자에서 `a`의 값을 덮어쓰지 않았기 때문에, `run()` 메서드가 기본값 `0`에서 시작할 수 있었던 것입니다.

// ================================================

// 아 그러니까 지금 코드는 기본 값 할당 후 추가적인 액션이 있어서 값이 변한건데, 
// new Car의 a는 클래스로 객체 생성 과정에서 a에 기본값이 할당되고 그 이후에 추가적인 액션이 없어서 기본값인 0으로 유지된다는거지?

// ------------------

// 네, 맞습니다! 100% 정확하게 이해하셨습니다. 🎯

// * **`cond` 클래스**: `int a`가 `0` (기본값)으로 할당되었지만, **`new cond(3)` (생성자)**와 **`obj.a = 5;` (main)**라는 **추가적인 액션**에 의해 값이 3으로, 다시 5로 변경되었습니다.

// * **`Car` 클래스**: `int a`가 `0` (기본값)으로 할당되었고, `run()` 메서드가 `++a`로 값을 바꾸기 **전까지는** 그 값을 덮어쓰는 **추가적인 액션(생성자나 main에서의 직접 할당)이 전혀 없었습니다.**

// 그래서 `cond`는 5에서 계산을 시작하고, `Car`는 0에서 계산(++a)을 시작하게 된 것입니다. 완벽합니다!

// ================================================

// 두 번째로 Thread 객체는 코드에서 직접 선언한 객체가 아니라 자바 프로그램에 내장된 객체인건가?

// -----------------

// 네, 맞습니다. `Thread`는 개발자가 `Car` 클래스처럼 직접 코드를 작성해서 선언한 것이 아니라, **자바(JDK)에 원래부터 내장되어 있는(built-in) 클래스**입니다.

// 조금 더 정확히 말하면:

// * **`Thread`는 클래스(설계도)입니다.** 📜
//     자바를 만든 개발자들이 "멀티스레딩(동시 작업) 기능을 사용하려면 '일꾼'이 필요할 테니, '일꾼'을 만드는 설계도를 미리 만들어 두자"라고 해서 
//     `java.lang` 패키지 안에 포함시켜 놓은 **기본 공구**입니다.

// * **`t1`은 객체(실체)입니다.** 👷
//     `main` 메서드에서 `new Thread(...)`를 한 것은, 자바가 제공한 `Thread`라는 **설계도**를 가져다가 `t1`이라는 **실제 일꾼 객체**를 만들어낸 것입니다.

// ### ## 레고(LEGO) 비유

// * **내장 클래스 (예: `Thread`, `String`, `System`)**:
//     레고 세트를 샀을 때, 상자 안에 이미 들어있는 **기본 브릭(brick)**들입니다. 자바가 미리 다 만들어 놓았습니다.

// * **사용자 정의 클래스 (예: `Car`, `Test`)**:
//     그 기본 브릭들을 조립해서 우리가 **새롭게 만든 창작물**(자동차, 집 등)입니다.

// 따라서 `new Thread(new Car())` 코드는, **"자바가 제공한 '일꾼' 브릭(`Thread`)을 가져와서, 우리가 만든 '자동차 작업(`Car`)'을 조립해, 
// `t1`이라는 실제 '일하는 자동차 로봇'을 완성했다"**는 의미가 됩니다.

// ================================================

// 그러면 Runnable은 뭐지 상속은 extends인데? implements는 뭐지?

// ----------------

// `Runnable`은 **인터페이스(Interface)**입니다. 이것이 `extends`와 `implements`의 핵심 차이점입니다.

// ---
// ## ## `Runnable`이란?

// `Runnable`은 자바에 내장된 **인터페이스**로, "실행 가능한 작업"이라는 **규격 또는 자격**을 의미합니다.

// `Thread` (일꾼)는 아무 객체나 작업으로 받지 않고, `Runnable`이라는 자격증을 가진 객체만 받습니다. `Runnable` 인터페이스는 `public void run()`이라는 메서드를 딱 하나 가지고 있습니다.

// `class Car implements Runnable`이라는 코드는, "**`Car` 클래스는 `Runnable` 자격증을 따겠습니다.**"라고 선언하는 것입니다. 
// 이 자격증을 따려면, `run()` 메서드를 실제로 구현(작성)해야 하는 의무가 생깁니다.

// ---
// ## ## `extends` vs. `implements`

// 두 키워드 모두 클래스에 기능을 추가하지만, 그 방식이 다릅니다.

// ### ### `extends` (상속) 👨‍👩‍👧

// * **대상**: **클래스 (Class)**
// * **의미**: "부모의 모든 것을 **물려받는다**."
// * **관계**: 부모-자식 관계입니다. (`class Dog extends Animal` -> "강아지는 동물이다.")
// * **특징**:
//     * 부모의 변수와 메서드를 (private 제외) 내 것처럼 바로 사용할 수 있습니다.
//     * 자바에서는 **단 하나의 클래스만** `extends` 할 수 있습니다. (단일 상속)
// * **비유**: **유산 상속**. 부모의 재산과 특징을 물려받습니다.

// ### ### `implements` (구현) 📜

// * **대상**: **인터페이스 (Interface)**
// * **의미**: "특정 **규격(기능)을 장착한다**."
// * **관계**: 계약 관계입니다. (`class Car implements Runnable` -> "Car는 '실행 가능' 규격을 만족시킨다.")
// * **특징**:
//     * 인터페이스에 정의된 (이름만 있는) 메서드를 **반드시 완성해야 할 의무**가 생깁니다. (`run()` 메서드를 직접 작성해야 함)
//     * **여러 개의 인터페이스를** `implements` 할 수 있습니다. (다중 구현)
// * **비유**: **자격증 취득**. '운전면허'(`Runnable`)라는 규격을 따기 위해 '운전하기'(`run()`) 기능을 구현(연습)해야 합니다. 한 사람이 운전면허, 요리사 자격증 등 여러 자격증을 가질 수 있습니다.

// **`Car` 클래스는 "자동차"이면서 동시에 "실행 가능한 작업"이라는 두 가지 정체성을 가져야 했습니다. 그래서 `implements Runnable`을 사용해 '실행 가능'이라는 추가 기능을 장착한 것입니다.**

// ================================================

// 그러니까 Runnable은 코드에서 선언한게 아닌 자바에 내장된 인터페이스라는건데, public void run() 메서드도 자바에 내장된 인터페에스가 갖고 있는 메서드인건가? 
// Runnable 인터페이스에 코드 작성자가 직접 정의한 메서드가 아니라?

// -------------------

// 네, 정확합니다\! **`public void run()` 메서드 자체는 `Runnable` 인터페이스에 (이름만) 정의되어 있는, 자바에 내장된 메서드**가 맞습니다.

// `Runnable` 인터페이스의 실제 설계도는 C언어의 헤더 파일처럼, 이렇게 생겼습니다.

// ```java
// // --- (이것이 자바(JDK) 내부에 미리 정의된 Runnable 인터페이스의 모습) ---
// public interface Runnable {
    
//     // "Runnable 자격증을 따려면,
//     //  반드시 public void run() 이라는 이름의 메서드를 완성해야 합니다."
//     //  라고 '강제'하는 역할.
//     public abstract void run(); 
    
//     // (실제 코드는 없고, 이렇게 선언만 되어 있습니다.)
// }
// // ----------------------------------------------------------------------
// ```

// -----

// ## \#\# "선언"과 "정의(구현)"의 차이

// 이것이 인터페이스를 이해하는 핵심입니다.

// 1.  **`Runnable` (자바 내장 인터페이스)**:

//       * `run()` 메서드를 \*\*선언 (Declaration)\*\*합니다.
//       * "이런 이름의 메서드가 **있어야 한다**"라고 **규칙**만 정합니다. (설계도의 빈칸)

// 2.  **`Car` (사용자 정의 클래스)**:

//       * `implements Runnable`이라고 약속했기 때문에, `run()` 메서드를 \*\*정의 (Definition) 또는 구현 (Implementation)\*\*합니다.
//       * "규칙대로 `run()` 메서드를 **만들겠다**. 내용은 이것이다(`{...}`) "라고 **실제 코드**를 작성합니다. (설계도의 빈칸 채우기)

// `Thread` 일꾼은 `run()`이라는 이름의 메서드를 실행하라고 프로그래밍되어 있기 때문에, `Car` 클래스가 그 `run()`이라는 이름의 빈칸을 채워 주기만 하면 되는 것입니다.

// =========================================

// 근데 그냥 Car t1 = new Car() 이런 식으로 객체를 생성해도 됐던거 아닌가? 왜 Thread를 쓴거지?

// --------------------

// 네, 날카로운 지적입니다. `Car t1 = new Car()`라고 객체를 생성하는 것 자체는 **당연히 가능합니다.**

// `Thread`를 쓴 이유는 \*\*"동시에 다른 작업을 하기 위해서"\*\*입니다. 즉, \*\*멀티스레딩(Multithreading)\*\*을 하기 위한 것입니다. 🧑‍🍳

// 만약 `Thread`를 쓰지 않고 `Car` 객체만 생성했다면, 프로그램은 완전히 다르게 동작했을 것입니다.

// -----

// ## \#\# `Thread`를 안 썼을 경우 (순차 실행)

// 만약 코드가 이랬다면:

// ```java
// public class Test {
//     public static void main(String args[]) {
//         Car t1 = new Car();
//         t1.run(); // t1.start()가 아님
        
//         System.out.println("메인 작업 끝!"); // (예시로 추가한 코드)
//     }
// }
// ```

//   * `Car t1 = new Car();` : `Car` 객체를 만듭니다.
//   * `t1.run();` : `main` 일꾼(기본 스레드)이 **직접 `run` 메서드를 실행**합니다.
//   * **문제**: `run` 메서드 안에는 0.1초마다 숫자를 출력하는 `while` 루프가 있습니다. 이 루프가 99까지 다 돌 때까지 (약 10초) `main` 일꾼은 `run` 메서드에 **발이 묶이게 됩니다.**
//   * `main` 일꾼은 `run` 메서드가 끝나기 전까지 다음 코드인 `System.out.println("메인 작업 끝!");`을 **절대 실행할 수 없습니다.**
//   * **비유**: 내가(메인 스레드) 밥을 짓기 시작(`run`)했는데, 밥이 다 될 때까지(10초) 다른 일(메인 작업)은 아무것도 못하고 밥솥 앞만 지키고 서 있는 것입니다.

// -----

// ## \#\# `Thread`를 썼을 경우 (동시 실행)

// ```java
// public class Test {
//     public static void main(String args[]) {
//         Thread t1 = new Thread(new Car());
//         t1.start(); // run()이 아님
        
//         System.out.println("메인 작업 끝!"); // (예시로 추가한 코드)
//     }
// }
// ```

//   * `Thread t1 = new Thread(new Car());` : \*\*"새로운 일꾼(`t1`)을 고용"\*\*하고, 그에게 `Car`라는 "작업 지시서"를 줍니다.
//   * `t1.start();` : `main` 일꾼이 `t1` 일꾼에게 "이제 **너 혼자 가서** 그 작업(`run`) 시작해\!"라고 **지시만 내립니다.**
//   * **결과**:
//     1.  `t1` 일꾼은 **별도의 공간에서** 0.1초마다 숫자를 출력하는 `while` 루프를 실행합니다.
//     2.  `main` 일꾼은 `t1`을 기다리지 않고, **즉시 다음 코드**인 `System.out.println("메인 작업 끝!");`을 실행합니다.
//   * **비유**: 내가(메인 스레드) 전기밥솥(`t1` 스레드)의 \*\*취사 버튼(`start`)\*\*을 누릅니다. 밥이 되는 동안(10초) 나는 자유롭게 다른 일(메인 작업)을 할 수 있습니다. 
//   밥솥은 **알아서 동시에** 밥을 짓습니다.

// 결론적으로, `Thread`를 쓴 이유는 `miles traveled`를 출력하는 작업을 **백그라운드에서 동시에 실행**시키고, 메인 프로그램은 다른 일을 계속할 수 있게 하기 위해서입니다.

// ======================================

// 그러니까 Thread 객체를 쓰지 않았을 경우에는 마지막에 1~99 까지의 miles traveled : a 가 한꺼번에 나오는데, Thread 객체를 활용하면, a가 증가할 때마다 출력도 같이 진행된다는 거야?

// ---------

// 아니요, 그 첫 번째 부분이 약간 다릅니다.

// `Thread`를 쓰지 않아도(`t1.run()`을 직접 호출해도) 1~99가 "한꺼번에" 나오는 것이 아닙니다.

// ### ## `Thread`를 쓰지 않았을 경우 (`t1.run()` 직접 호출)

// * `run()` 메서드 안에는 `Thread.sleep(100)` (0.1초 멈춤) 코드가 있습니다.
// * `main` 일꾼이 `run`을 직접 실행하면, "miles traveled : 1"을 출력하고 **0.1초 멈추고**, "miles traveled : 2"를 출력하고 **0.1초 멈추고**... 이렇게 99까지 **순서대로, 
// 0.1초 간격으로 천천히** 나옵니다.
// * **가장 큰 차이점**은, 이 10초(0.1초 * 99번) 동안 `main` 일꾼은 `run` 메서드에 **발이 묶여서** 다른 일(예: "메인 작업 끝!" 출력)을 전혀 못 한다는 것입니다.

// ### ## `Thread`를 썼을 경우 (`t1.start()` 호출)

// * 말씀하신 대로, **"a가 증가할 때마다 출력이 같이 진행됩니다."** (`t1` 일꾼이 0.1초 간격으로 "miles traveled : 1", "miles traveled : 2"... 를 순서대로 출력합니다.)
// * **동시에**, `main` 일꾼은 이 작업을 `t1`에게 맡기고 **기다리지 않고** 자신의 다음 일(예: "메인 작업 끝!")을 하러 갑니다.
// * 그래서 사용자는 "메인 작업 끝!"이 거의 즉시 출력되고, 그와 **별개로** "miles traveled : 1", "miles traveled : 2"... 가 0.1초 간격으로 출력되는 것을 보게 됩니다.

// ---
// ### ## 요약

// | 방식 | `t1.run()` (Thread 안 씀) | `t1.start()` (Thread 씀) |
// | :--- | :--- | :--- |
// | **출력** | 0.1초 간격으로 **순차적** 출력 | 0.1초 간격으로 **순차적** 출력 |
// | **차이점** | 10초 동안 **모든 것이 멈춤** | `main` 작업과 **동시에** 일어남 |
// | **비유** | 내가 10초간 밥 짓고, 다 짓고 나서야 다른 일 함 | 밥솥이 10초간 밥 짓는 동안, 나는 다른 일 함 |

// =========================================

// 그니까 그건 Thread 써도 밖에서 사람이 보기엔 똑같이 도합 9.9 초 멈춰있는거 아니야? 내부에서 대체 뭐가 다른건지 이해가 잘 안되네?

// ------------------------

// 아니요, 밖에서 보기에도 **전혀 다릅니다.**

// `Thread`를 쓰지 않으면, **프로그램 전체가 9.9초 동안 '먹통'이 됩니다.**

// `Thread`를 쓰면, **프로그램은 '먹통'이 되지 않고 즉시 다음 작업을 처리합니다.**

// 이것이 '내부'의 가장 큰 차이이며, '밖'에서 사용자가 경험하는 결정적인 차이입니다.

// ---
// ### ## 🔒 `Thread`를 안 썼을 때 (t1.run() 직접 호출)

// **"파일 다운로드 프로그램"**을 예로 들어보겠습니다. 이 프로그램에는 '다운로드 시작' 버튼과 '취소' 버튼이 있습니다.

// 1.  사용자가 '다운로드 시작' 버튼을 누릅니다. (`t1.run()` 호출)
// 2.  `run` 메서드는 10초가 걸립니다. (0.1초마다 멈추니까)
// 3.  `main` 일꾼(메인 스레드)은 이 10초짜리 `run` 메서드를 **혼자** 처리해야 합니다.
// 4.  **문제**: `main` 일꾼은 프로그램의 **모든 버튼 클릭, 화면 스크롤 등**을 처리하는 유일한 일꾼입니다.
// 5.  **결과**: `main` 일꾼이 10초 동안 다운로드 작업에 묶여있는 동안, 사용자가 '취소' 버튼을 **아무리 눌러도 프로그램은 반응하지 않습니다.** 화면이 하얗게 변하며 '먹통'이 됩니다.
// 6.  10초가 지나 `run`이 끝나야만, 프로그램은 다시 반응하기 시작합니다.

// ---
// ### ## 🔑 `Thread`를 썼을 때 (t1.start() 호출)

// 똑같은 '파일 다운로드 프로그램'입니다.

// 1.  사용자가 '다운로드 시작' 버튼을 누릅니다. (`t1.start()` 호출)
// 2.  `main` 일꾼은 **"새 일꾼(`t1`)을 고용"**하고, 10초짜리 `run` 작업을 그에게 맡기고 **자기는 즉시 복귀**합니다.
// 3.  **결과**:
//     * **새 일꾼 `t1`**: 백그라운드에서 10초 동안 열심히 다운로드를 진행합니다.
//     * **`main` 일꾼**: 다른 일을 할 준비를 합니다. 사용자가 '취소' 버튼을 누르면 **즉시 반응**하여 `t1`에게 "작업 중지!" 신호를 보낼 수 있습니다. 스크롤도 부드럽게 잘 됩니다.

// ---
// ### ## 요약

// `Thread`를 쓴다는 것은 **"시간이 오래 걸리는 작업을 '메인 일꾼'이 직접 하지 않고, '새로운 일꾼'에게 시켜서 동시에 처리한다"**는 의미입니다.

// `Thread`를 쓰지 않으면 메인 일꾼이 모든 일을 혼자 다 하느라 프로그램이 멈추고, `Thread`를 쓰면 메인 일꾼은 사용자의 요구에 즉각 반응할 수 있게 됩니다. 이것이 내부 동작의 가장 큰 차이입니다.

// ==========================================

// 그러니까 출력 상황 자체는 사람이 보기에 변하지는 않는데, 사용자가 거기서 추가적인 액션을 취할 때, Thread를 쓰지 않으면 액션을 취하는게 불가능하다는 소리 아니야?

// -------------------

// 네, **그게 정확히 핵심입니다!** 🎯

// `Thread`를 쓰지 않으면 `main` 스레드(프로그램의 유일한 일꾼)가 10초짜리 `run` 메서드에 꽉 묶여버려서, 사용자의 '추가적인 액션'(버튼 클릭, 스크롤 등)을 **처리할 여력 자체가 없어집니다.
// ** 프로그램이 '먹통'이 되는 거죠.

// ---
// ## ## 출력 상황도 사실 다릅니다

// 다만, "출력 상황 자체가 변하지 않는다"는 부분은 실제로는 조금 다릅니다. **출력되는 순서**가 달라집니다.

// * **`Thread` 안 씀 (`t1.run()` 호출)**
//     `main` 일꾼이 `run`을 끝까지 다 실행해야 다음으로 넘어갈 수 있습니다.
//     1.  "miles traveled : 1" (0.1초 쉼)
//     2.  "miles traveled : 2" (0.1초 쉼)
//     3.  ... (9.9초가 흐름) ...
//     4.  "miles traveled : 99" (0.1초 쉼)
//     5.  (run 메서드가 드디어 끝남)
//     6.  **"메인 작업 끝!"** (10초 뒤에야 출력됨)

// * **`Thread` 씀 (`t1.start()` 호출)**
//     `main` 일꾼이 `t1`에게 일을 시키고 자기는 바로 다음 일을 합니다.
//     1.  **"메인 작업 끝!"** (즉시 출력됨)
//     2.  (동시에 `t1` 일꾼이 별도로...)
//         "miles traveled : 1" (0.1초 쉼)
//         "miles traveled : 2" (0.1초 쉼)
//         ...

// 밖에서 보기에도 "메인 작업 끝!"이 언제 나오는지, 그 순서가 완전히 다릅니다. 그리고 말씀하신 대로 사용자의 추가 액션에 **반응할 수 있느냐(Thread 씀) 없느냐(Thread 안 씀)**는 
// 치명적인 차이가 생깁니다.

// =========================================

// 근데 코드에는 "메인 작업 끝!" 이 없는데 일단 이거 어디서 튀어나온건지 모르겠고, 없으면 그냥 사람이 보기엔 똑같은게 맞잖아

// -------------------------

// 네, 맞습니다. "메인 작업 끝!"이라는 예시 코드가 없으니, **사용자님의 말씀대로 이 코드만 놓고 보면 사람이 보는 
// 최종 출력 결과(0.1초 간격으로 "miles traveled : 1" ... "99"가 나오는 것)는 `t1.run()`을 쓰나 `t1.start()`를 쓰나 똑같습니다.**

// "메인 작업 끝!"은 `main` 일꾼이 `t1` 일꾼과 **별개의 다른 일**을 하는 상황을 보여드리기 위해 제가 임의로 추가한 예시였습니다.

// ---
// ## ## 결과가 같아도 내부 동작은 완전히 다릅니다

// 출력 결과는 같아 보여도, **프로그램이 종료되는 시점과 일하는 방식**은 완전히 다릅니다.

// ### ### `t1.run()` (Thread 안 씀)

// 1.  `main` 일꾼이 `run`을 실행합니다.
// 2.  `main` 일꾼이 0.1초 쉬고, 0.1초 쉬고... 9.9초 동안 `run` 메서드를 **끝까지** 실행합니다.
// 3.  `run` 메서드가 끝나면 `main` 메서드도 끝납니다.
// 4.  **프로그램 종료 시점**: 약 9.9초 뒤

// ### ### `t1.start()` (Thread 씀)

// 1.  `main` 일꾼이 `t1` 일꾼에게 "너 가서 `run` 실행해!"라고 **명령만 내립니다.**
// 2.  `main` 일꾼은 자기 할 일(명령 내리기)이 끝났으므로 **즉시 종료**합니다.
// 3.  `t1` 일꾼은 `main` 일꾼이 사라졌든 말든, **혼자 남아서** 0.1초 쉬고, 0.1초 쉬고... 9.9초 동안 `run` 메서드를 **끝까지** 실행합니다.
// 4.  `run` 메서드가 끝나면 `t1` 일꾼도 종료됩니다.
// 5.  **프로그램 종료 시점**: (마찬가지로) 약 9.9초 뒤 (`t1` 일꾼이 일을 마칠 때)

// ---
// ## ## 핵심은 "메인 스레드의 자유"

// 이 코드처럼 `main` 일꾼이 `t1`을 시작시키고 **아무 다른 할 일이 없다면**, `t1.start()`를 쓰는 것의 이점이 겉으로 드러나지 않습니다.

// 하지만 `Thread`를 쓴다는 것 자체가 "나는 `main` 일꾼을 붙잡아두지 않고, **다른 일을 할 수 있는 자유로운 상태로 두겠다**"라는 의도입니다. 
// 이 코드에 다른 작업이 한 줄이라도 추가되는 순간, 그 차이는 명확해집니다.