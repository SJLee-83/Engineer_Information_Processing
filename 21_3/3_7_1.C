#include <stdio.h>
struct jsu {
    char nae[12];
    int os, db, hab, hhab;
};

int main() {
    struct jsu st[3] { {"데이터", 95, 98}, {"데이터2", 84, 91}, {"데이터3", 86, 75}};
    struct jsu* p;
    p = &st[0];
    (p + 1)->hab = (p + 1)->os + (p + 2)->db;
    (p + 1)->hhab = (p + 1)->hab + p->os + p->db;
    printf("%d", (p + 1)->hab + (p + 1)->hhab);
}

// 알겠습니다. 이 C 코드가 컴파일되고 실행되어 결과가 나오기까지의 전체 과정을 설명해 드릴게요.

// **최종 실행 결과: `511`**

// ---
// ## ## 1. 컴파일 (Compile Time)

// (프로그램 실행 전, 코드를 기계어로 번역하는 단계)

// 1.  **문법 검사**: 컴파일러가 코드를 읽으며 C 문법에 맞는지 확인합니다.
//     * `struct jsu`라는 사용자 정의 자료형(설계도)을 인식합니다.
//     * `st`라는 `jsu` 타입의 배열 3칸이 선언되고 초기화되는 것을 확인합니다.
//     * `p`라는 `jsu` 구조체를 가리키는 포인터 변수를 확인합니다.
//     * `(p + 1)->hab` 같은 포인터 연산자가 문법에 맞게 사용되었는지 확인합니다.
// 2.  **메모리 주소 계산**: 컴파일러는 `st` 배열이 메모리에 어떻게 배치될지 계획합니다. `st[0]`, `st[1]`, `st[2]`가 연속으로 붙어있게 되죠.
// 3.  **코드 변환**: `(p + 1)->hab` 같은 C 코드를 "p의 주소에서 `jsu` 구조체 1개 크기만큼 뒤로 이동한 다음, `hab` 멤버의 위치에 값을 저장하라"는 식의 기계어로 번역합니다.

// ---
// ## ## 2. 실행 (Runtime)

// (번역된 기계어 코드가 실제로 실행되는 단계)

// 1.  **메모리 할당 (스택)**: `main` 함수가 시작되고, `st` 배열을 위한 공간이 스택 메모리에 할당됩니다. 초기값은 다음과 같이 채워집니다.
//     * **`st[0]`**: `{"데이터", 95, 98, 0, 0}`
//     * **`st[1]`**: `{"데이터2", 84, 91, 0, 0}`
//     * **`st[2]`**: `{"데이터3", 86, 75, 0, 0}`
//     > (초기화되지 않은 멤버 `hab`와 `hhab`는 0으로 자동 초기화됩니다.)

// 2.  **포인터 초기화**: `p = &st[0];`
//     * `p`라는 포인터 변수가 `st[0]`의 실제 메모리 주소(예: "100번지")를 가리키게 됩니다.

// `]

// 3.  **첫 번째 계산**: `(p + 1)->hab = (p + 1)->os + (p + 2)->db;`
//     * **`(p + 1)`**: `p`가 100번지(`st[0]`)를 가리키므로, `(p + 1)`은 `jsu` 구조체 1개 크기만큼 뒤인 `st[1]`("101번지")을 가리킵니다.
//     * **`(p + 2)`**: `p`에서 `jsu` 구조체 2개 크기만큼 뒤인 `st[2]`("102번지")를 가리킵니다.
//     * **연산**:
//         * `(p + 1)->os` = `st[1].os` = **84**
//         * `(p + 2)->db` = `st[2].db` = **75**
//     * **저장**: `(p + 1)->hab` (즉, `st[1].hab`)에 `84 + 75`의 결과인 **159**가 저장됩니다.
//     * *현재 `st[1]`의 상태*: `{"데이터2", 84, 91, 159, 0}`

// 4.  **두 번째 계산**: `(p + 1)->hhab = (p + 1)->hab + p->os + p->db;`
//     * **연산**:
//         * `(p + 1)->hab` = `st[1].hab` = 방금 계산한 **159**
//         * `p->os` = `st[0].os` = **95**
//         * `p->db` = `st[0].db` = **98**
//     * **저장**: `(p + 1)->hhab` (즉, `st[1].hhab`)에 `159 + 95 + 98`의 결과인 **352**가 저장됩니다.
//     * *현재 `st[1]`의 상태*: `{"데이터2", 84, 91, 159, 352}`

// 5.  **최종 출력**: `printf("%d", (p + 1)->hab + (p + 1)->hhab);`
//     * `(p + 1)->hab` (`st[1].hab`)의 값 **159**와
//     * `(p + 1)->hhab` (`st[1].hhab`)의 값 **352**를 더합니다.
//     * `159 + 352` = **511**
//     * 화면에 `511`이 출력됩니다.


// 네, 맞습니다! **100% 정확한 이해입니다.**

// 자바에서 `main` 함수가 실행되기 전의 **"준비 단계(클래스 로딩)"**에서 메모리에 미리 준비되는 것은 **오직 `static` 키워드가 붙은 멤버들뿐**입니다.

// ---
// ## ## 1. main 함수 실행 전 (클래스 로딩 단계)

// * **대상**: `static` 변수, `static` 메서드
// * **동작**:
//     * `private static Connection _inst = null;`
//     * `public static Connection get() { ... }`
//     * `public static void main(...)` (main도 static이죠!)
// * **이유**: 이 멤버들은 **클래스(설계도) 자체에 소속된 공용 멤버**이기 때문에, 객체를 만들지 않고도 호출할 수 있어야 합니다.

// ## ## 2. main 함수 실행 중 (런타임 단계)

// * **대상**: `static`이 붙지 않은 모든 **인스턴스 멤버**
// * **동작**:
//     * `private int count = 0;`
//     * `public void count() { ... }`
// * **이유**: 이 멤버들은 **객체(실체)에 소속된 개인 멤버**입니다. 이 변수들은 **`new Connection()`**이라는 코드가 **실제로 실행되는 순간**에야 비로소 Heap 메모리에 자신만의 공간을 할당받고 `0`으로 초기화됩니다.

// **요약:**
// "준비 단계"는 `static` 멤버들만 준비시키고, `count`와 같은 인스턴스 멤버들은 `main` 함수가 실행되다가 `new` 명령어를 만날 때까지는 메모리에 존재조차 하지 않습니다.