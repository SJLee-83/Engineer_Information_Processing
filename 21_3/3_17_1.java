public class Test {
    public static void main(String[] args) {
        int w = 3, x = 4, y = 3, z = 5;
        if((w == 2 | w == y) & !(y > z) & (1 == x ^ y != z)) {
            w = x + y;
            if(7 == x ^ y != w)
                System.out.println(w);
            else
                System.out.println(x);
        }
        else {
            w = y + z;
            if(7 == y ^ z != w)
                System.out.println(w);
            else    
                System.out.println(z);
        }
    }
} 

// 이 코드의 최종 실행 결과는 **7**입니다.

// 이 결과는 자바의 논리 연산자(특히 `&`, `|`, `^`)가 어떻게 작동하는지 정확히 이해해야 풀 수 있는 문제입니다.

// ---
// ### ## 코드 실행 절차

// 1.  **변수 초기화**
//     `main` 메서드가 시작되고 변수들이 다음과 같이 초기화됩니다.
//     * `w = 3`
//     * `x = 4`
//     * `y = 3`
//     * `z = 5`

// 2.  **첫 번째 `if` 조건문 평가**
//     `if((w == 2 | w == y) & !(y > z) & (1 == x ^ y != z))`
//     이 복잡한 `if`문은 `&` 연산자로 연결된 세 부분으로 나뉩니다.

//     >   **💡 중요**: 자바에서 `&`와 `|`는 `&&`와 `||`와 다릅니다. `&`와 `|`는 "단축 평가(short-circuit)"를 하지 않습니다. 즉, **조건의 좌우를 모두 검사**합니다.

//     * **(Part 1)**: `(w == 2 | w == y)`
//         * `w == 2` → `3 == 2` → **`false`**
//         * `w == y` → `3 == 3` → **`true`**
//         * `false | true` → **`true`**

//     * **(Part 2)**: `!(y > z)`
//         * `y > z` → `3 > 5` → **`false`**
//         * `!(false)` → **`true`**

//     * **(Part 3)**: `(1 == x ^ y != z)`
//         * `^` (XOR) 연산자는 두 항의 값이 **서로 다를 때** `true`가 됩니다.
//         * `1 == x` → `1 == 4` → **`false`**
//         * `y != z` → `3 != 5` → **`true`**
//         * `false ^ true` → **`true`**

//     * **최종 결합**: `(Part 1) & (Part 2) & (Part 3)`
//         * `true & true & true` → **`true`**

//     첫 번째 `if`문의 조건이 `true`이므로, `else` 블록은 무시되고 `if` 블록 안의 코드가 실행됩니다.

// 3.  **`if` 블록 내부 실행**
//     * `w = x + y;`
//         * `w = 4 + 3`이 실행됩니다.
//         * `w`의 값은 `3`에서 **`7`**로 변경됩니다.

// 4.  **두 번째(중첩된) `if` 조건문 평가**
//     * `if(7 == x ^ y != w)`
//         * `^` (XOR) 연산자가 사용되었습니다.
//         * `7 == x` → `7 == 4` → **`false`**
//         * `y != w` → `y`의 값은 `3`, `w`의 값은 `7`입니다. `3 != 7` → **`true`**
//         * `false ^ true` → **`true`**

//     두 번째 `if`문의 조건도 `true`이므로, `else` 블록은 무시되고 `if` 블록 안의 코드가 실행됩니다.

// 5.  **최종 출력**
//     * `System.out.println(w);`
//     * 현재 `w` 변수에 저장된 값은 **7**입니다.
//     * 따라서 화면에 **7**이 출력됩니다.


// 네, 그 두 가지 질문은 C/Java 계열 언어에서 매우 중요하고 혼동하기 쉬운 지점입니다.

// ### \#\# 1. &, | 와 &&, || 의 차이

// 네, "양쪽을 무조건 검사하는지 여부"(`Short-Circuit`, 단축 평가)가 **논리 연산** 시의 가장 큰 차이점이 맞습니다.

// 하지만 더 근본적인 차이는, `&`와 `|`는 원래 **비트(bit) 연산자**이고 `&&`와 `||`는 **논리 연산자**라는 점입니다.

// #### \#\#\# `&&` 와 `||` (논리 연산자)

//   * **이름**: **논리 AND, 논리 OR**
//   * **용도**: `boolean` 타입의 값 두 개를 비교할 때만 사용합니다.
//   * **핵심 기능 (단축 평가 ⚡)**:
//       * **`A && B`**: `A`가 `false`이면, `B`는 아예 쳐다보지도 않고 **즉시 `false`로 결론**냅니다. (어차피 `false` 확정)
//       * **`A || B`**: `A`가 `true`이면, `B`는 아예 쳐다보지도 않고 **즉시 `true`로 결론**냅니다. (어차피 `true` 확정)
//       * **이유**: 불필요한 연산을 줄여 성능을 높이기 위해서입니다.

// #### \#\#\# `&` 와 `|` (비트 연산자)

//   * **이름**: **비트 AND, 비트 OR**

//   * **용도 1 (주 용도)**: **정수(int)의 2진수 비트**를 하나하나 비교할 때 사용합니다.

//       * 예: `5 & 3` → `0101 & 0011` → `0001` (결과: 1)

//   * **용도 2 (부수적 용도)**: `boolean` 값에 사용할 수 있습니다.

//   * **핵심 기능 (단축 평가 ❌)**:

//       * `A & B` 또는 `A | B`를 하면, **결과가 뻔히 보여도 무조건 양쪽(`A`, `B`)을 모두 실행**합니다.
//       * 이전 문제의 `if`문에서 `&&` 대신 `&`를 쓴 것은 "단축 평가 없이 모든 조건을 다 검사해라"는 의도적인 선택이었던 것입니다.

// -----

// ### \#\# 2. `^` (XOR) 연산자란?

// **XOR**은 \*\*eXclusive OR (배타적 논리합)\*\*의 약자입니다.

// 가장 쉽게 외우는 방법은 \*\*"두 값이 서로 다르면 `true`"\*\*입니다. "배타적"이라는 말은 "둘 다 같으면(true든 false든) 배척한다"는 뜻입니다.

// #### \#\#\# `boolean` 연산 (진리표)

// `OR`(`|`)과 비슷하지만, 둘 다 `true`일 때의 결과가 다릅니다.

// | A | B | `A ^ B` (XOR) | 설명 |
// | :--- | :--- | :--- | :--- |
// | `true` | `true` | **`false`** | (두 값이 같으므로 `false`) |
// | `true` | `false`| **`true`** | (두 값이 **다르므로** `true`) |
// | `false`| `true` | **`true`** | (두 값이 **다르므로** `true`) |
// | `false`| `false`| **`false`** | (두 값이 같으므로 `false`) |

// 이전 문제의 `(1 == x ^ y != z)` → `(false ^ true)`는 "두 값이 **다르므로**" 최종 결과가 `true`가 된 것입니다.

// #### \#\#\# 정수(int) 연산

// `&`나 `|`처럼 정수(int)에 사용하면 2진수 비트별로 XOR 연산을 합니다.

//   * 예: `5 ^ 3`
//     ```
//       0101  (5)
//     ^ 0011  (3)
//     ---------
//       0110  (6)
//     ```
//   * **결과**: 6